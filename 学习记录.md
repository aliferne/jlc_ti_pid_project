# 前言

开发的是TI的MSPM0G3507芯片，立创开发板，EIDE配置较为麻烦，跟着下面走一遍。

# 开发环境搭建

见[此文](https://wiki.lckfb.com/zh-hans/tmx-mspm0g3507/keil-beginner/install.html)

不过这个教的是Keil上开发，我们要在Vscode上开发

需要修改几处地方

为了确保到时候keil上也能用，需要先按照上面文档的步骤走一遍，然后我们来专门说说怎么配置Vscode，你可以选择EIDE插件，然后修改构建配置中的构建器选项，也可以直接修改 `eide.json`，因为有个步骤需要两个都修改，我们索性就只讲 `eide.json` 的改法：

```json
"beforeBuildTasks": [
    {
        "name": "Linking syscfg",
        "command": "cd \"${projectRoot}\" && cmd.exe /C \"${projectRoot}\\syscfg.bat '${projectRoot}\\empty' empty.syscfg\"",
        "disable": false,
        "abortAfterFailed": true,
        "stopBuildAfterFailed": true
    }
],
```

修改里面的 `command` 属性即可，由于我这个文件夹的工作目录为 `TI-PID`，且 Keil 中表示项目根目录的 `$P` 不适用于 EIDE，所以需要改为 `${projectRoot}`，然后经过我debug发现`syscfg.bat`传入的参数是`empty`这个目录以及里面的`empty.syscfg`，所以需要配置为 `'${projectRoot}\\empty'` 和 `empty.syscfg`。
而你也可以配置一下`name`，从而使得build时显示此名称。

linker里面的misc-controls修改为此路径：

```json
"linker": {
    "output-format": "elf",
    "misc-controls": "source/ti/driverlib/lib/keil/m0p/mspm0g1x0x_g3x0x/driverlib.a"
}
```

（因为我们的 `${projectRoot}` 的子文件夹里面有`source`，不需要像keil里面配置那样子退回到父级的父级文件夹）

然后是GUI界面的配置：

```batch
@echo off

:: Path of TI's nw.exe
set NW_EXECUTOR="E:/TI/sysconfig/nw/nw.exe"
:: Path of TI's sysconfig
set SYSCONF="E:/TI/sysconfig"
:: The path to the syscfg of the project
set SYSCONF_FILE="./empty/empty.syscfg"

:: execute GUI
%NW_EXECUTOR% %SYSCONF% %SYSCONF_FILE%
```

接下来powershell里面运行`./launchGui`就行了，之后配置管脚输出啥的和在Keil里面设置是一样的。

有个究极大坑！！！

**EIDE自带的JLink工具包是V6.90版本的**（它的实用工具里面只有V6.90版本的Jlink），要去 `${userRoot}/.eide/tools/`目录下把JLink删掉！然后再装最新版的JLink，接下来去设置里面配置下JLink的路径就行了。不然V6.90的不支持新版芯片，各种烧录问题能把你脑子干烧🙂。

我这里`${userRoot}`等价于`C:/Users/a3230`

最后我选择装到`C:/Users/a3230/.eide/tools`去，然后Jlink目录就成了JLink_V830（这是JLink驱动自己设置的）

Cortex-Debug插件需要自己去设置一下，首先是在 `settings.json` 里面设置一些工具依赖的路径，比如armToolChain（gcc-arm-none-eabi啥的），这个自己去找教程安装，Keil不提供的。

然后在.vscode文件夹里面创建个`launch.json`文件，内容如下：

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Debug (gdbserver)",
            "cwd": "${workspaceFolder}",
            "executable": "${workspaceFolder}/build/empty_LP_MSPM0G3507_nortos_keil/ti-pid.elf",    // Path to the elf file
            // Waring! HEX file can't be assigned for debug!
            "request": "launch",
            "type": "cortex-debug",
            "servertype": "jlink",
            "device": "MSPM0G3507",
            "serverpath": "C:/Users/a3230/.eide/tools/JLink_V830/JLinkGDBServerCL.exe", // Path to JLinkGDBServer
            "interface": "swd", // Use SWD interface
            // NOTE: 建议先烧录再Debug，这个插件对双任务的支持不算很好，build完没flash就开始debug了
            "preLaunchTask": "build and flash" // Build and flash before launch
        }
    ]
}
```

然后最好再次设置一下`.eide.json`的一些信息，你可以先在EIDE插件里面随便选一个芯片型号，然后再去文件里面改成这块芯片的型号（因为EIDE可能更新频率不太经常，没办法涵盖所有芯片）

```json
"cpuInfo": {
    "vendor": "TI", // manufactor
    "cpuName": "MSPM0G3507" // chip name
},
```

**配置完之后会更方便一些，就不用再每次都设置一下芯片型号了**（烧录时JLink驱动会打开，让你设置芯片型号）。

实际上只要你给EIDE配好了最新的JLink驱动，那其实也可以直接可视化配置，不用去改`eide.json`，这是我新近发现的。

然后就可以愉快的调试了！

# 英文名词缩写的含义

这个章节主要是因为库函数里面太多以前学51时完全没接触过的名词了，特地增加这个章节，方便查阅。

## 串口通信的缩写

1. **NVIC**是Nested Vectored Interrupt Controller的缩写，它**是一种中断控制器，用于管理微控制器的中断请求**

2. **IRQ**是Interrupt Request的缩写，它**是一种硬件中断信号，用于通知处理器有外部设备需要处理**（就是中断位）。当外部设备需要处理器注意时，它会发送IRQ信号，处理器会暂停当前的任务，处理中断请求，然后再继续执行之前的任务。在计算机系统中，IRQ通常用于处理键盘、鼠标、硬盘等外部设备的输入和输出操作。

3. **IRQN**是Interrupt Request Number的缩写，它**表示中断请求的编号**。在计算机系统中，每个外部设备都会分配一个唯一的IRQ编号，以便处理器能够区分和处理不同的中断请求。当外部设备需要处理器注意时，它会发送IRQ信号，并附带相应的IRQ编号，处理器根据IRQ编号确定需要处理的中断请求。

4. **IIDX** 是 Interrupt Identifier Index 的缩写。在嵌入式系统和微控制器编程中，**IIDX 通常用于表示中断标识符的索引**（就是我们学51时学到的中断号 `interrupt 1`）。这个索引用于在**中断向量表**（概念和51相同，本质是一块内存区域，用于存储中断服务例程的地址和其他相关信息）**中查找和识别特定的中断服务例程**（ISR）。每个中断源都会分配一个唯一的 IIDX，以便系统可以正确地处理相应的中断请求。

5. **中断向量表**（Interrupt Vector Table）是计算机系统中用于存储中断服务例程（Interrupt Service Routine, ISR）地址的表格。当处理器接收到一个中断请求时，它会查找中断向量表以确定应该执行哪个中断服务例程。
 
**中断向量表通常包含以下信息**：
**中断号**（Interrupt Number）：唯一标识每个中断源。
**中断服务例程地址**（ISR Address）：指向处理该中断的中断服务例程的内存地址。
当某个外部设备或内部事件触发中断时，处理器会根据中断号查找中断向量表，然后跳转到相应的中断服务例程地址执行中断处理代码。处理完成后，处理器会返回到之前被中断的程序继续执行。

中断向量表在系统启动时被初始化，并且通常存储在内存的一个固定位置。不同的处理器架构和操作系统可能会有不同的中断向量表实现方式。

6. 

# 扩展知识

## 单片机编程和更新的名词

***ISP***（In-System Programming）和 ***IAP***（In-Application Programming）**都是用于微控制器和嵌入式系统编程和更新的技术**。它们允许在设备已经安装在实际系统中的情况下进行编程和更新，而无需从系统中移除设备。

1. ISP(In-System-Programming)：**ISP技术允许开发者通过外部编程器或调试器连接到目标设备，对设备内部的闪存进行编程或更新**。这意味着开发者可以在设备安装在现场的情况下对设备进行重新编程，而无需拆开设备或移除芯片。ISP通常用于生产过程中的编程，以及在设备已经部署后进行现场更新。

简单点说就是我们现在正在做的，用J-Link烧录代码到芯片上。

2. IAP(In-Application-Programming)：**IAP技术允许设备在运行其应用程序的同时对自身的闪存进行编程或更新**。这意味着**设备可以在不需要外部编程器的情况下进行现场更新**。IAP通常用于需要远程更新固件的设备，如远程传感器节点、工业控制系统等。

简单点说就是我们带的智能手表的系统更新之类的。

# 简单的延时函数

延时函数是编程中常用的函数，用于让程序暂停执行一段时间。在嵌入式系统中，延时函数通常用于等待硬件设备完成某个操作，或者实现用户交互中的延迟效果。

# 点亮LED

点LED原理还需要废话吗？制造电势差。

开发板PB22引脚接了LED的正极（小样输出能力还挺彪悍）。

工程已经搞定了，powershell切到根目录跑一下 `./launchGui.bat`，然后配置下GPIO啥的，再把 `ti_msp_dl_config.h` 头文件和 `ti_msp_dl_config.c` 源文件的代码用GUI生成的文件覆盖即可（可以直接在GUI里面选择到这里的empty文件夹，然后一键保存），具体的看立创文档。

## 控制引脚状态的dl库函数

在`dl_gpio.h`库函数文件中，有三个函数可以控制引脚状态

**相关函数说明**

> `__STATIC_INLINE void DL_GPIO_setPins(GPIO_Regs* gpio, uint32_t pins)`

该函数**为控制引脚输出高电平**，按照本例程中LED的引脚，则可以写为 `DL_GPIO_setPins(LED1_PORT,LED1_PIN_22_PIN);`

> `__STATIC_INLINE void DL_GPIO_clearPins(GPIO_Regs* gpio, uint32_t pins)`

该函数**为控制引脚输出低电平**，按照本例程中LED的引脚，则可以写为 `DL_GPIO_clearPins(LED1_PORT,LED1_PIN_22_PIN);`

> `__STATIC_INLINE void DL_GPIO_togglePins(GPIO_Regs* gpio, uint32_t pins)`

该函数**为控制引脚的电平翻转**，如果原来是高电平则变为低电平，如果原来是低电平则变为高电平。按照本例程中LED的引脚，则可以写为`DL_GPIO_togglePins(LED1_PORT,LED1_PIN_22_PIN);`

```c
#include "ti_msp_dl_config.h"
#include "type.h"

void delay(uint ms)
{
    uint i, j;
    /*
     * 下面的嵌套循环次数是由主控频率和编译器生成的指令周期大致计算出来的
     * 实际开发需要通过测试调整来达到所需时间。
     */
    for (i = 0; i < ms; i++) {
        for (j = 0; j < 8000; j++) {
            __asm__("nop"); // NOP指令，空操作
        }
    }
}

int main(void)
{
    SYSCFG_DL_init();   // 这一步会初始化所有的必要系统设置

    while (1) {
        DL_GPIO_clearPins(GREEN_PORT, GREEN_PIN_22_PIN);
        delay(1000);    // 延时大体1s
        DL_GPIO_setPins(GREEN_PORT, GREEN_PIN_22_PIN);
        delay(1000);

        /*
            * 或写成
            DL_GPIO_togglePins(GREEN_PORT, GREEN_PIN_22_PIN);
            delay(1000);
         */
    }
}
```

对了，**TI里面只能是`int main()` 声明，哪怕并没有`return 0;`**，应该存在什么特殊的机制。

- 引脚名称命名规则：`GUI设置的引脚名_PORT`
- 引脚编号命名规则：`GUI设置的引脚名_GUI设置的引脚编号_PIN`

# 系统延时

## 延时的作用

在MSPM0或其他微控制器的编程中，延时被广泛使用，主要有以下一些原因：

1. **处理硬件**：**许多硬件都需要一些时间来响应某个命令**。例如，如果在一个程序中你启动一个电动机然后立即检查其状态，你可能会得到一个错误的读数，因为电动机可能还没有足够的时间开始旋转。此时你需要使用 `delay()` 函数让系统等待一段时间，使得电动机有足够的时间响应。
2. **用户交互**：我们常常**需要在用户交互中实现延迟效果**。例如，在蜂鸣器播放音乐时，音符之间需要一段沉默的时间。或者，在闪烁LED灯的情况下，"开"和"关"状态之间需要延时以控制闪烁的速度。
3. **节省能源**：在一些应用中，比如电池供电的系统，如果不在需要的时候长期保持系统的高速运转，那么电池的寿命会大大缩短。在此情况下，我们可以让系统在一段时间后进入待机或低功耗模式，直到下一个理周期到来。
4. **定时操作**：在许多项目中，我们常常需要实现一些特定时间点的操作。例如，在自动灌溉系统中，我们可能需要在每天的特定时间点进行灌溉。在间隔测量中，我们可能每隔一段时间采集一次数据。

尽管**延时函数在很多情况下非常有用，但也需要注意其阻塞性质**。

**过度依赖阻塞延时可能会导致程序对其他事件的响应不及时**。为了更好的在MSPM0上进行多任务编程，我们**还可以学习一些非阻塞延时的编程技术**。

> ❓什么是阻塞延时？
> **阻塞延时是在程序执行过程中，当某个操作或函数需要一定时间才能完成时，程序会暂停执行直至该操作完成，这段时间程序被阻塞了**。阻塞延时可能会导致程序运行速度变慢或出现**假死**现象。 举个例子，假设你想要煮开水来泡茶。通常情况下，你会将水壶放在炉灶上加热，等待水烧开后才能用。在这个过程中，存在阻塞延时。 当你将水壶放在火上时，程序可以看作是“等待”水烧开的操作。在这个等待过程中，你不能立即得到热水来泡茶，需要耐心等待水煮沸。期间，你可能无法做他与烧水无关的事情，因为你需要留意水壶，并等待时机。即便家里着火了，你也还是在等待烧水。

## 实现延时的方式

有很多，但只介绍三种：`空代码延时`，`TI工程自带的延时`，`使用滴答定时器`

### 空代码延时

又名NOP延时，就是个机器指令，表示不执行任何操作，但是会消耗时钟周期。

应用场景有以下几个：

1. **时序延时**，在SPI或者I2C通信中会用到NOP，在某些硬件相关的编程中（E2PROM等），精确的时序控制非常重要。通过插入NOP指令，可以确保其他硬件操作有足够的时间来完成。
2. **调试**：在调试程序时，开发者可能会插入NOP指令来暂时“冻结”程序，以便观察程序的某个特定状态。
3. 占位符：在开发过程中，开发者可能暂时不知道要在某个位置放置什么代码，此时可以用NOP作为占位符（这个太难绷了，还不如Python的`pass`呢）

简单空延时如下：

```c
void delay(void)
{
    for (int i = 0; i < 1000; i++) {
        // 不执行任何操作
        // 你也可以放一个 __asm__("nop");
    }
}
```

优点是能用，缺点是不准。

### TI工程自带的延时

提供的函数API为`delay_cycles(cycles)`，一个可以根据主控频率进行计算时间的延时函数。

源代码：

```c
/**
 * @brief Alias for DL_Common_delayCycles
 */
#define delay_cycles(cycles) DL_Common_delayCycles(cycles)

/**
 * @brief   Consumes the number of CPU cycles specified.
 *
 * @param[in] cycles  Floor number of cycles to delay.
 *                    Specifying zero will result in the maximum
 *                    possible delay. Note that guarantees at least
 *                    this number of cycles will be delayed,
 *                    not that exactly this number of cycles will be
 *                    delayed. If a more precise number of cycle delay value
 *                    is needed, GPTimer is recommended.
 *
 *                    Typical variance from this function is 10 cycles or
 *                    less assuming that the function is located in flash and
 *                    that caching is enabled. Disabling caching may result in
 *                    wait-states when fetching from flash.
 *                    Other variance occurs due:
 *                      - Amount of register stacking/unstacking around API entry/exit
 *                      - Value of cycles relative to 4-cycle loop counter
 *                      - Placement of code on a 2- or 4-byte aligned boundary
 */
void DL_Common_delayCycles(uint32_t cycles);

void DL_Common_delayCycles(uint32_t cycles)
{
    /* this is a scratch register for the compiler to use */
    uint32_t scratch;

    /* There will be a 2 cycle delay here to fetch & decode instructions
     * if branch and linking to this function */

    /* Subtract 2 net cycles for constant offset: +2 cycles for entry jump,
     * +2 cycles for exit, -1 cycle for a shorter loop cycle on the last loop,
     * -1 for this instruction */

    __asm volatile(
#ifdef __GNUC__
        ".syntax unified\n\t"
#endif
        "SUBS %0, %[numCycles], #2; \n"
        "%=: \n\t"
        "SUBS %0, %0, #4; \n\t"
        "NOP; \n\t"
        "BHS  %=b;" /* branches back to the label defined above if number > 0 */
        /* Return: 2 cycles */
        : "=&r"(scratch)
        : [ numCycles ] "r"(cycles));
}
```

**通过汇编语言的NOP指令，通过主频计算执行代码的时间周期，去实现的延时。而时间周期TI团队也已经为大家计算好了，可以直接在工程中调用`delay_cycles(主频hz);`函数即可**。

实现一秒延时： 

```c
// 我们工程模板设为32Mhz
// 有修改则另说
delay_cycles(32000000);
``` 

实现一毫秒延时：

```c
// 同上
delay_cycles(32000000/1000);
```

### 使用滴答定时器

**基本所有arm内核芯片都有的功能，可以精准延时**

#### 什么是滴答定时器

**`SysTick`定时器可用作标准的下行计数器，是一个24位向下计数器，有自动重新装载能力，可屏蔽系统中断发生器**。

Cortex-M0处理器内部包含了一个简单的定时器，所有基于M0内核的控制器都带有`SysTick`定时器,这样就**方便了程序在不同的器件之间的移植**。**`SysTick`定时器可用于操作系统，提供系统必要的时钟节拍，为操作系统的任务调度提供一个有节奏的“心跳”**。正因为所有的M0内核的芯片都有`SysTick`定时器，这在移植的时候不像普通定时器那样难以移植。

学51的时候学过了，本质就是个计数器，但这里直接就能重装了，不需要像51一样配几个寄存器才能计时。

RCU 通过 `MCLK` 作为 Cortex 系统定时器（`SysTick`）的外部时钟，即使用`MCLK`计时，MCLK默认为32MHz。通过对 `SysTick` 控制和状态寄存器的设置，即可控制或读取。关于系统时钟的介绍可参考用户手册的第128页。

**`SysTick`定时器设定初值并使能之后，每经过1个系统时钟周期，计数值就减1，减到0时，SysTick计数器自动重新装载初值并继续计数，同时内部的COUNTFLAG标志位被置位，触发中断**（前提是开启中断）。

#### 配置 `SysTick`

[教程](https://wiki.lckfb.com/zh-hans/tmx-mspm0g3507/keil-beginner/delay.html#_4-3-2-%E5%BC%80%E5%90%AFsysconfig%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7)

很简单，就是去SysTick那一栏开个初始化定时器周期，然后设置周期计数值，然后设置下中断优先级（可以不设置），和开启定时器并启动。

设置周期为32000就可以做到定时1ms。

然后一个简单的使用代码大体如此：

```c
#include "ti_msp_dl_config.h"

volatile uint32_t delay_times = 0;

// 和SysTick一起实现精准ms计时
void delay_ms(uint32_t ms) {
    delay_times = ms;
    while(delay_times); // > 0 时卡死在这里
}

int main(void) {
    SYSCFG_DL_init();

    while (1) {
        // 暂时为空循环
    }
}

// 滴答定时器中断服务函数
void SysTick_Handler(void) {
    if (delay_times) {
        delay_times--;
    }
}
```

> 🔅C语言扩展
> **在C语言中，`volatile` 是一个关键字，用来告诉编译器不要对它所修饰的变量做任何优化，因为这个变量的值可能会随时被意想不到的因素改变，比如硬件中断、多线程操作等**。`volatile` **告诉编译器不要将对这个变量的读写操作优化掉，每次访问都要从变量地址中读取或写入**。在多线程或与硬件相关的编程中，**`volatile` 经常用来声明那些程序之外其他实体可能会修改的变量，以确保每次访问都能获取最新的值，避免编译器优化导致的意想不到的问题**。

上面的代码 `SysTick_Handler` 和我们之前学51的时候写的 `void Interrupt_ISR() interrupt 1` 是一样的，就是在系统触发中断之后就会进入这个函数，然后执行函数内的代码。简单点的逻辑就是，先设置好一个初始值（ms），然后定时1ms，每次都去减这个值，最后就定时完毕。

#### LED灯闪烁实验

相当简单，间隔1s闪烁即可

```c
#include "ti_msp_dl_config.h"
#include "type.h"

// 和提供的例程略有不同
// volatile 依然不能少
// 但为了避免 delay_times 定义为 uint时
// 减到0后还往下减，导致未定义行为
// 这里设置为有符号的int
volatile int delay_times = 0;

void delay_ms(int ms)
{
    delay_times = ms;
    while (delay_times >= 0);
}

int main(void)
{
    SYSCFG_DL_init();

    while (1) {
        // 每1s反转一次电平
        DL_GPIO_togglePins(LED1_PORT, LED1_PIN_22_PIN);
        delay_ms(1000);
    }
}

void SysTick_Handler(void)
{
    if (delay_times >= 0) {
        delay_times--;
    } else {
        delay_times = 0; // 小于0则归0
    }
}
```

或者如此，这种风格类似于我们学51时宋老师（《手把手教你学51单片机》の作者）的风格：

```c
#include "ti_msp_dl_config.h"

// 在这里 volatile 依然是有必要的，
// 因为该值的修改情况不确定（中断函数和主函数均对其访问了），
// 编译器无法产生正确的优化
// THINK：请思考——我只要把`flag1s = 0;`放到中断函数里去就可以省略volatile了？
volatile uint8_t flag1s = 0; 

int main()
{
    SYSCFG_DL_init();

	
    while (1) {	
        if (flag100ms) {
            flag100ms = 0;
            DL_GPIO_togglePins(LED1_PORT, LED1_PIN_22_PIN);
        }
    }
}

void SysTick_Handler()
{
    // delay for 1s
    // 这里的volatile反而不是必须的，
    // 因为它在中断函数内部更改，值的改变情况是可预测的
    // 请你重新回顾 volatile 关键字的作用，十分重要！🤗
    static volatile uint16_t counter = 0;
	
    if (counter < 1000) {
        counter++;
    } else {
        counter   = 0;
        flag100ms = 1;
    }
}
```

上面有个`THINK`，**Answer是No**，因为主函数依然访问了变量`flag1s`，不信邪的话可以改一下试试。

# 按键

## 结构、原理

独立按键的主要结构组成包括：按钮、外壳、弹簧、触点、导电片和引脚。**当按下按键时，导电片触碰到触点，从而形成一个闭合电路**。

独立按键原理主要是基于机械触点和电气触点之间的关系。**当按键未被按下时，通常触点是分开的，电路是断开的**。当用户**按下按键时，触点在弹簧和导电片的作用下形成闭合，这时电路连通，微控制器能够读取到该按键触发的信号**。

## 消抖

按键消抖分为硬件消抖和软件消抖

软件消抖就是加延时（延后检测）和多次检测，确保确实是按下的。

板子上三个按键，RST，BSL，B21

- RST是芯片复位功能按键，不能通过软件的方式去控制该按键
- BSL是特殊按键，它接到了PA18引脚，该引脚是用于进入升级模式进行串口下载等操作的特殊引脚，不建议使用
- B21按键就是用户的可以操控的按键，将PB21引脚接入了一个按键，通过按键接到GND

[原理图](https://wiki.lckfb.com/zh-hans/tmx-mspm0g3507/keil-beginner/key.html#_5-6-%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE%E5%8E%9F%E7%90%86%E5%9B%BE)

B21由于内部上拉电阻的存在，是高电平的，按键按下后会变成低电平。

> `PA18`引脚为MSPM0G3507芯片的BSL引脚，**用于启动芯片的BootLoader模式**，非特殊情况，**请确保在给开发板通电时，PA18引脚为低电平，否则将会启动BootLoader模式**，导致**无法正常执行之前所下载的代码**。

## 按键点灯实验

在打开GUI界面配置时，需要注意把PB21配置成**输入模式**（检测外部电压变化）和**上拉电阻**（确保高电平）

我们要借助函数 `DL_GPIO_readPins`，它的原型是：

`__STATIC_INLINE uint32_t DL_GPIO_readPins(GPIO_Regs* gpio, uint32_t pins)`

也就是说它会返回一个 `uint32_t`（`static`的），也就是对应引脚的状态位，所以需要查数据手册，比如以PA18为例。当PA18引脚检测到低电平时，返回的值是0；当PA18引脚检测到高电平时，对应的32位寄存器中PA18的位将会被置1，返回的值为0x40000，换为2进制就是：100 0000 0000 0000 0000。

因此，我们有种简单的方法——只要判断引脚电平是不是为0就行，这样子就不用去找数据手册数数了。

最简单的示例如下：

```c
#include "ti_msp_dl_config.h"

int main() {
    // static可加可不加、你也可以使用volatile来避免编译器优化
    uint32_t last_state = 0;
    while (1) {
        last_state = DL_GPIO_readPins(BTN_PORT, BTN_PIN_21_PIN);
        if (last_state == 0) {
            // 按下就亮，松开就灭
            DL_GPIO_setPins(LED1_PORT, LED1_PIN_22_PIN);
        } else {
            DL_GPIO_clearPins(LED1_PORT, LED1_PIN_22_PIN);
        }
    }
}
```

然后让我们引入消抖，从简单的NOP到复杂点的中断：

NOP:

```c
#include "ti_msp_dl_config.h"

void delay_ms(uint16_t ms) {
    for (uint16_t i = 0; i < ms; i++) {
        __NOP();    // 还是NOP，和__asm__那个等效
    }
}

int main()
{
    uint32_t onPressed = 0; // 检测是否按下按键（0为按下）
    SYSCFG_DL_init();

    while (1) {
        // 我们等会把它抽象成一个函数，叫 `Btn_Detector`
        onPressed = DL_GPIO_readPins(BTN_PORT, BTN_PIN_21_PIN);
        if (onPressed == 0) {
            delay_ms(100);
            onPressed = DL_GPIO_readPins(BTN_PORT, BTN_PIN_21_PIN);
            if (onPressed == 0) {
                DL_GPIO_togglePins(LED_PORT, LED_PIN_22_PIN);
            }
        }
    }
}
```

中断：

```c
#include "ti_msp_dl_config.h"

volatile uint8_t time_10ms = 10; // 刚开始的时候定时10ms

void delay_ms(uint8_t ms)
{
    time_10ms = ms; // 设置
}

int main()
{
    SYSCFG_DL_init();

    while (1) {
        // do other things
    }
}

void Btn_Detector()
{
    uint32_t onPressed = 0;
    onPressed          = DL_GPIO_readPins(BTN_PORT, BTN_PIN_21_PIN);
    if (onPressed == 0) {
        onPressed = DL_GPIO_readPins(BTN_PORT, BTN_PIN_21_PIN);
        if (onPressed == 0) {
            DL_GPIO_togglePins(LED_PORT, LED_PIN_22_PIN);
        }
    }
}

void SysTick_Handler()
{
    // 定时完10ms之后继续定时
    if (time_10ms > 0) {
        time_10ms--;
    } else {
        time_10ms = 10;
    }
    Btn_Detector(); // 我们丢到这里去检测按键，每10ms轮询一下
}
```

# 中断

## 中断的概念

中断的概念我们在51的时候已经学过了

简单点说就是在芯片中突然出现了某件事情，使得芯片需要暂时放下正在执行的任务，而去处理这个突发事件，导致突发事件的就是中断，芯片处理的就是中断函数。举个例子，比如你在切菜，突然水壶烧开了，这个时候你就会先停下切菜，去把水壶关了，这就是典型的中断。在CPU处理中断之前，会执行一系列的操作，比如保存当前堆栈变量、保存计数器的值（放下菜刀，擦干手），然后才会处理中断函数。处理完中断函数之后，CPU会恢复之前的状态，继续执行被中断的任务（继续切菜）。

## 中断的类型

中断有两种类型：硬件中断；软件中断

1. 硬件中断：通常由外部设备的物理事件引发，如按下按钮、达到定时器的时间、或数据到达串行端口。当这些事件发生时，微处理器会立即暂停其当前的任务，并跳转到一个预先定义的中断服务程序（ISR）来响应该事件。
2. 软件中断：由软件指令引发，通常用于更复杂的处理任务。像操作系统的系统调用就使用了软件中断。

正好在这里插入一句——**中断函数的名称是定死了的**，**名称**可以见[这个文件](./empty/keil/startup_mspm0g350x_uvision.s)，**在大概90多行的时候有名称的汇总**。

# 中断的一个小demo

我们上面检测按键时给了两个例子，**使用延时的属于阻塞代码，这玩意会强行让CPU睡大觉，不准干活，实际上是个不好的实践**，之后我又给了个使用中断的例子，这属于**非阻塞代码，CPU不会睡大觉，可以继续执行其他任务**。

```c
#include "ti_msp_dl_config.h"

void delay_ms(uint32_t ms) {
    for (uint32_t i = 0; i < ms; i++) {
        __NOP();    // 还是NOP，和__asm__那个等效
    }
}

int main()
{
    uint32_t onPressed = 0;
    SYSCFG_DL_init();

    while (1) {	        
        onPressed = DL_GPIO_readPins(BTN_PORT, BTN_PIN_21_PIN);
        if (onPressed == 0) {
            delay_ms(100);         // 一般情况
            // 一个比较极端的情况，此时会彻底卡死，
            // 只有板子上的LED会亮
            // delay_ms(100000);
            onPressed = DL_GPIO_readPins(BTN_PORT, BTN_PIN_21_PIN);
            if (onPressed == 0) {
                DL_GPIO_setPins(LED_PORT, LED_PIN_22_PIN);
            }
        }
        // 让面包板上的LED亮
        DL_GPIO_setPins(LED2_PORT, LED2_PIN_3_PIN);
    }
}
```

上面我们整了一个用延时的情况，我会插入一个视频，第一个场景是一开始就按下按键，然后两个LED和板子上的LED都亮了，第二个场景是晚点再按下按键，两个LED不亮，板子上的LED亮。

<video demo1>
   <source src="./demo/video/一个使用延时的不良影响的例子.mp4" type="video/mp4">
</video>

接下来我们再使用中断看下情况：

```c
#include "ti_msp_dl_config.h"

volatile uint8_t time_10ms = 10; // 刚开始的时候定时10ms

void delay_ms(uint8_t ms)
{
    time_10ms = ms; // 设置
}

int main()
{
    SYSCFG_DL_init();

    while (1) {
        // 翻转面包板上的LED
        DL_GPIO_togglePins(LED2_PORT, LED2_PIN_3_PIN);
    }
}

void Btn_Detector()
{
    uint32_t onPressed = 0;
    onPressed          = DL_GPIO_readPins(BTN_PORT, BTN_PIN_21_PIN);
    if (onPressed == 0) {
        onPressed = DL_GPIO_readPins(BTN_PORT, BTN_PIN_21_PIN);
        if (onPressed == 0) {
            DL_GPIO_togglePins(LED_PORT, LED_PIN_22_PIN);
        }
    }
}

void SysTick_Handler()
{
    // 定时完10ms之后继续定时
    if (time_10ms > 0) {
        time_10ms--;
    } else {
        time_10ms = 10;
    }
    Btn_Detector(); // 我们丢到这里去检测按键，每10ms轮询一下
}
```

这个非阻塞的例子（使用中断）就很完美，我们既做到了让面包板上的两个LED亮，又做到了按下按键后板子上的LED也亮。

现象如该视频所示：

<video demo2>
   <source src="./demo/video/一个使用中断的非阻塞例子.mp4" type="video/mp4">
</video>


中断在这里的作用呢，是让CPU在必要时才执行一些操作，比如上面的例子中，**我们把检测按键的操作丢到中断函数里面去，这样就保证了CPU不会一直轮询和按键相关的任务**（CPU不知道啥时候会按按键，所以我们还不如让CPU不时去看看情况，而不是让它一直盯梢），**转而去处理一些比较重要的任务**。这大大节省了CPU的资源，因此中断在实际项目中应用非常普遍。

# 外部中断

**外部中断是硬件中断的一种，它由微控制器外部的事件引发**。
**微控制器的某些引脚被设计为对特定事件的发生做出响应**，例如按钮的按压、传感器的信号改变等。**这些指定的引脚通常被称为“外部中断引脚”**。
**在发生外部中断事件时，当前的程序执行会被立即停止，并跳转到对应的中断服务程序（ISR）进行处理。处理完毕后，程序会返回到被中断的地方继续执行**。
对于嵌入式系统、实时系统来说，外部中断的使用是非常重要的，能帮助系统对外部事件进行即时响应，大大提高了系统的**效率和实时性**。提供了许多引脚作为可用的外部中断引脚，可以通过配置这些引脚来进行外部中断实验。

## 事件驱动型中断

> MSPM0系列把**CPU中断，DMA触发，以及外设触发外设**，都统称为**事件**（Event），**触发源称为事件发布者**（Event Publisher），**相应中断的外设被称为事件订阅者**（Event Subscriber）。

这段实在太像前端和Qt里面的 `EventDriven` 的思想了，所以我管这个叫做事件驱动型中断（自创名词）

事件管理器传输的事件有：

- **作为中断请求 (IRQ) 传输到 CPU 的外设事件（静态事件）** —— 示例：GPIO 中断会发送到 CPU
- **作为 DMA 触发器传输到 DMA 的外设事件（DMA 事件）** —— 示例：传输到 DMA、请求 DMA 传输的 UART 数据接收触发器
- **传输到另一个外设以直接触发硬件中操作的外设事件（通用事件）** —— 示例：TIMx 计时器外设将周期性事件发布到 ADC 订阅者端口，ADC 使用该事件触发采样开始（ADC触发采样）

下图为MSPM0系列的事件安排表。其中绿色表示事件发布者（发送），将外设上发生的事件告诉总线；红色为事件订阅者（接收），接收总线上的事件情况。

![MSPM0系列的事件安排表](./demo/pic/MSPM0系列的事件安排表.png)

## 外部中断的作用和优势

外部中断功能在开发中具有以下作用和优势：

1. **实时响应外部事件**：外部中断功能可以让你**在检测到外部事件触发时立即作出响应**。这些外部事件可以是来自传感器、按钮、开关、接收到的信号等等。通过外部中断，就可以实时地捕捉到这些事件并执行相应的操作，而无需频繁地轮询或等待。
2. **节省计算资源**：外部中断**允许你将处理外部事件的任务转移给芯片的硬件，从而节省了处理器的计算资源**。相比于软件轮询方式，外部中断可以降低对处理器的负担，使其可以更有效地利用其他资源进行更复杂的任务。
3. **精确的事件捕捉**：外部中断功能**能够以非常精确的方式捕捉外部事件的触发**。你可以通过配置中断触发方式（如上升沿、下降沿、任意电平等）来适应不同的外部事件，并在事件发生时立即中断当前程序的执行，转而执行中断服务函数。
4. **高优先级处理**：外部中断**可以设置为高优先级处理，优先于当前正在执行的程序。这对于需要立即响应的重要事件非常有用，如紧急通知、传感器检测等**。当外部事件触发时，处理器将立即转移到中断服务函数执行，确保及时、准确地处理相关操作，避免对处理程序的延迟。
5. **多路中断处理**：支持多路外部中断，你**可以将多个外部事件与不同的中断引脚相连，从而实现对多个事件的并行处理。这使得你可以处理多个传感器、开关等外部事件**，提高系统的灵活性和扩展性。

总之，外部中断功能提供了实时响应、节省计算资源、精确事件捕捉、高优先级处理和多路中断处理等优势。它为我们提供了更加灵活、高效的方式来处理外部事件，并帮助构建更强大、可靠的应用。

## 配置外部中断

我们还是以点亮LED灯为例子，但这次不再使用定时消抖而是直接使用按键的外部中断功能。

需要重新配置下B21按键的一些参数，就是**设置一下开启中断**，**在GUI界面的 Interrupts/Events 里面**，参数分别为：

- Enable Interrupts：**是否开启中断**
- Interrupt Polarity：**设置中断优先级**
- Trigger Polarity：**设置触发方式**（上升沿/下降沿/两个沿都触发）
- Event Publishing Channel：**设置事件发布通道**

我们设置为：是；默认；上升沿触发（按下后回弹比较准一些，此时一整个按键按下的操作都执行完了）；不设置

**此外顺带说一下，芯片上所有引出的GPIO端口均可设置外部中断功能**。

**在上面的那张图上，GPIO属于GROUP1的**（看左侧第一个`GPIOx`），**所以我们下面的中断函数是**`GPOUP1_IRQHandler`。以及读取中断位开启按键的中断，都要看看官方SDK。

代码如下：

```c
#include "ti_msp_dl_config.h"

int main()
{
    SYSCFG_DL_init();
    // 设置开启按键引脚的GPIOB端口中断
    NVIC_EnableIRQ(BTN_INT_IRQN);

    while (1) {
        DL_GPIO_togglePins(LED2_PORT, LED2_PIN_3_PIN); // Set LED to ON
    }
}

void GROUP1_IRQHandler()
{
    // 读取Group1的中断寄存器，并清除中断标志位
    switch (DL_Interrupt_getPendingGroup(DL_INTERRUPT_GROUP_1)) {
        // 检查是否为BTN的中断，注意是INT_IIDX
        case BTN_INT_IIDX:
            // 如果按键按下变为高电平
            if (DL_GPIO_readPins(BTN_PORT, BTN_PIN_21_PIN) > 0) {
                // 翻转板子上的LED
                DL_GPIO_togglePins(LED_PORT, LED_PIN_22_PIN);
            }
            break;

        default:
            break;
    }
}
```

一些上面我们没见过的名词，如*NVIC*，*IIDX* 等，[转名词缩写的串口通信部分](#串口通信的缩写)

这个比我们的用定时器的好太多了，按下必然点亮，不会莫名其妙的按下后又熄灭和按下好几次才触发了。

# 串口通信

**串口是指外设和处理器之间通过数据信号线、地线和控制线等，按位进行传输数据的一种通讯方式**。尽管**传输速度比并行传输低**。但**串口可以在使用一根线发送数据的同时用另一根线接收数据**。 **这种通信方式使用的数据线少**，**在远距离通信中可以节约通信成本**。**串口通信最重要的参数是波特率、数据位、停止位和奇偶校验位**，这些**参数在两个通信端口之间必须一致**。

## 参数介绍

### 波特率

衡量通信速度的参数，它表示每秒钟发送的bit的个数

### 数据位

衡量通信中实际数据位的参数，表示一个信息包里包含的数据位的个数

### 停止位

**用于表示单个信息包的最后位，典型值为 1、1.5 和 2 位**。由于数据是在传输线上传输的，每个设备都有自己的时钟，很有可能在通信过程中出现不同步，**停止位不仅仅表示传输的结束，还能提供校正时钟同步的机会**。**停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率也越慢**。

### 奇偶检验位

表示一种简单的检查错误的方式

## 串口工作模式

- 单工：在通信的任意时刻只能有一个发送方（A -> B 或 B -> A）（如电报）
- 半双工：在通信的任意时刻可以有不同的发送方和接收方，但时间需要错开（如对讲机）
- 全双工：在通信的任意时刻双方均可作为发送方（如微信）

## 串口通信协议

**串口通信协议定义了在串口上进行数据交换的规则和格式**。

常见的串口通信协议包括ASCII协议、Modbus协议、RS-232协议等。协议规定了数据的帧结构、数据格式、校验方式等，确保发送和接收双方按照相同的规则进行数据交换，从而实现数据的正确传输和解析。

### USART协议规则

**一位一位地传输，每传输一个字符总是以起始位开始，以停止位结束**，
**字符之间没有固定的时间间隔要求**。
**每一个字符的前面都有一位起始位（低电平）**，
**后面由 7 位数据位组成，接着是一位校验位，最后是停止位**。
**停止位后面是不定长的空闲位**，
**停止位和空闲位都规定为高电平**。

## 串口通信的作用及优势

串口是计算机和外部设备之间最常见的通信接口之一，具有重要的作用和广泛的应用。在计算机领域，串口的重要性体现在以下几个方面：

1. 数据传输：串口是一种常用的数据传输接口。通过串口，计算机可以与各种外部设备进行数据交换和通信。无论是传感器、执行器、显示器、打印机还是其他外部设备，串口通信都可以实现数据的传输和控制。
2. 远程控制和监控：串口通信被广泛应用于远程控制和监控领域。通过串口，计算机可以远程控制设备的动作，并实时监测设备的状态和数据信息。这在工业控制、自动化系统、远程监控等场景中具有重要的作用。
3. 调试和故障排查：串口通信是调试和故障排查的重要工具。通过串口，计算机可以与嵌入式系统、单片机等进行通信，实时监控和调试程序，输出调试信息，进行错误定位和排查，并对系统进行状态监测和故障诊断。
4. 硬件连接：串口可以作为计算机与各种外部设备之间的连接桥梁。通过串口，可以连接和控制各类外部设备，如传感器、执行器、外围设备等。串口能够提供稳定的数据传输和双向通信功能。
5. 通信协议：串口通信协议是计算机与外部设备之间数据传输的规范和约定。通过定义不同的协议，可以实现不同设备之间的数据交互和通信。常见的串口通信协议有UART、RS-232、RS-485等。

总之，串口对于计算机和外部设备之间的通信具有重要的作用。它是数据传输、远程控制和监控、调试和故障排查的关键工具，是计算机与外部设备连接和通信的桥梁。通过串口通信，可以实现与各种外部设备的数据交互，提高系统的功能和性能。具体到串口通信的作用和优势，可以总结如下：

1. 数据传输：串口通信可以实现双向数据的可靠传输，包括发送和接收各种类型的数据。
2. 远程控制和监控：通过串口通信，可以实现远程控制设备的动作，并实时监测设备的状态和数据信息。
3. 调试和故障排查：串口通信是调试和故障排查的重要工具，可以实时监控和调试程序，输出调试信息，进行错误定位和排查。
4. 灵活性和实时性：串口通信具有较高的灵活性和实时性，可以根据需求调整波特率和参数，并及时处理数据和响应外部事件。
5. 成本效益：串口通信使用简单、成本低廉的硬件，并且广泛应用于各个领域，是一种经济实用的通信方式。

总之，串口通信在数据传输、远程控制与监控、调试和故障排查等方面具有重要的作用和诸多优势，是实现设备间数据交互和系统功能的重要手段。

## M0G350X系列的串口说明

只有四个串口——UART0到UART3，支持功能丰富（见[数据手册](./mspm0g3507.pdf)第67页或看下图）

![UART特性](./demo/pic/UART特性.png)


并非所有引脚都支持串口，可以看立创总结好的外设功能图，买他们的板子有送的。也可以看下面的图片：

![立创提供的外设功能图](./demo/pic/立创提供的外设功能图.png)

## 串口通信的配置

### 串口通信的硬件连接

在开发板上有集成了一块 *CH340E*，**CH340E 是一款流行的 *USB 转串口芯片*，广泛用于各种需要串口通信的设备中**。它提供了一种低成本、便捷的方式将 USB 接口转换成标准的串口（RS232/RS485/TTL），广泛应用于单片机开发、嵌入式系统、通信设备等多个领域。

**在开发板上，我们可以通过一个数据线，接入到开发板的TYPE-C接口上，即可与开发板进行串口通信**。 而**CH340E接入到了`PA10`(UART0_TX)与`PA11`(UART0_RX)引脚**。这两个引脚是串口0引脚，此外我顺带列举一下其他串口的引脚吧（[数据手册](./mspm0g3507.pdf)第12页往下）：

1. 串口1： `PB4`(UART1_TX)和`PB5`(UART1_RX)
2. 串口2： `PB15`(UART2_TX)和`PB16`(UART2_RX)
3. 串口3： `PB12`(UART3_TX)和`PB13`(UART3_RX)

此外其实这里只是其中一部分引脚，还有些引脚也支持串口通信，更详细的还是需要去看[数据手册](./mspm0g3507.pdf)。

### 串口时钟的配置

串口时钟来源有三个：

1. BUSCLK：**由内部高频振荡器提供的CPU时钟**，通常芯片**默认设置为了`32MHz`**
2. MFCLK：**只能使用固定的`4MHz`时钟**(参考用户手册132页)。**开启的话需要配置时钟树的`SYSOSC_4M`分支**，才能够正常开启
3. LFCLK：**由内部的低频振荡器提供时钟**（`32KHz`）。**在运行、睡眠、停止和待机模式下有效，使用该时钟可以实现更低的功耗**。

更详细的配置教程见[这里](https://wiki.lckfb.com/zh-hans/tmx-mspm0g3507/keil-beginner/uart.html#_7-8-3-%E4%B8%B2%E5%8F%A3%E6%97%B6%E9%92%9F%E7%9A%84%E9%85%8D%E7%BD%AE)

然后我们的示例：

```c
#include "ti_msp_dl_config.h"

// 使用dl库内置的 `delay_cycles` 函数来延时
#define delay_ms(X) delay_cycles((CPUCLK_FREQ / 1000) * (X));

// 需要注意使用 volatile
volatile uint8_t uart_data    = 0; // uart数据

void Uart0_Transmit_Char(char ch);      // 发送字符
void Uart0_Transmit_String(char *data); // 发送字符串
void Uart0_Receive_String(void);

int main()
{
    SYSCFG_DL_init();
    // 清除串口中断标志
    NVIC_ClearPendingIRQ(UART_0_INST_INT_IRQN);
    // 串口中断使能
    NVIC_EnableIRQ(UART_0_INST_INT_IRQN);

    while (1) {
        // LED引脚高电平
        DL_GPIO_setPins(LED_PORT, LED_PIN_22_PIN); // 点亮LED
        delay_ms(500);
        // LED引脚低电平
        DL_GPIO_clearPins(LED_PORT, LED_PIN_22_PIN); // 点亮LED
        delay_ms(500);
    }
}

void Uart0_Transmit_Char(char ch)
{
    // 等待串口空闲
    while (DL_UART_isBusy(UART_0_INST) == true);
    DL_UART_Main_transmitData(UART_0_INST, ch); // 发送数据
}

void Uart0_Transmit_String(char *data)
{
    // 字符串为空时不发送
    while (*data) {
        Uart0_Transmit_Char(*data++); // 发送数据
    }
}

void UART_0_INST_IRQHandler()
{
    switch (DL_UART_getPendingInterrupt(UART_0_INST)) {
        case DL_UART_IIDX_RX: // 如果是接收中断
            // 将发送过来的数据保存在变量中
            uart_data = DL_UART_Main_receiveData(UART_0_INST);
            // 然后再发出去
            Uart0_Transmit_Char(uart_data);
            break;
        default: // 其他串口中断不管
            break;
    }
}
```

备注一下，**软件用sscom调试串口通信**，别用stc-isp，这个对51支持好，其他的都不太行。

对了，TI库的代码风格还是很好的，有兴趣的话可以看看，想研究下DL库是怎么写成的话就看看，顺带就当学习别人的分层架构思想了😁。

#### 相关代码的一些说明

1. **串口中断必须手动开启**。通过**函数 `NVIC_EnableIRQ`指定开启某一个中断**。
**开启之前要先清除中断标志位，否则开启中断后将会自动进入中断**。

2. **串口发送数据。可以通过函数 `DL_UART_Main_transmitData` 将字符数据发出**。
**但为了确保不会阻塞发送通道的数据，需要增加忙判断**。例如，你在发送ABCD时，刚刚准备发A，A还没有发送出去，芯片就要发送B了，这样就导致了数据丢失。

3. 串口接收数据。接收数据本案例是通过串口中断接收的方式，一有数据过来就马上中断接收，非特殊情况不会有阻塞。

4. **如需要使用C语言中的`printf`函数，需要进行以下操作。 在`.s`文件中修改堆栈的大小。此处我将堆大小修改为`0x100`**。

**之后还需要重定义 `fputc` 以支持 `printf` 通过串口0输出，使用时需要加上 `stdio.h` 头文件**。

```c
int fputc(int ch, FILE *stream)
{
  while( DL_UART_isBusy(UART_0_INST) == true );
  DL_UART_Main_transmitData(UART_0_INST, ch);
  return ch;
}
```

这个相对麻烦些，还有一个宏需要定义

```h
#if !defined(__MICROLIB)
//不使用微库的话就需要添加下面的函数
#if (__ARMCLIB_VERSION <= 6000000)
//如果编译器是AC5  就定义下面这个结构体
struct __FILE
{
        int handle;
};
#endif

FILE __stdout;
//定义_sys_exit()以避免使用半主机模式
void _sys_exit(int x)
{
        x = x;
}
#endif
```

# 定时器

定时器是单片机内部集成，可以通过编程控制。单片机的定时功能是通过计数来实现的，当单片机每一个机器周期产生一个脉冲时，计数器就加一。定时器的主要功能是用来计时，时间到达之后可以产生中断，提醒计时时间到，然后可以在中断函数中去执行功能。

**MSPM0G系列一共有7个定时器，可以分为2种类型，通用计时器（TIMG）和高级控制计时器（TIMA）。不同类型的定时器所拥有的功能数量不同，一般高级定时器的功能最多，通用定时器次之**。具体功能对照可以查看[用户手册](./mspm0g3507.pdf)的P70。

## 高级控制定时器

**TIMA模块由一个16位自动重载计数器组成**，由可编程预调节器驱动，最多四个捕获/比较（CC）块用于多个捕获/比较，带死区插入的PWM输出和间隔定时。TIMA具有广泛的事件生成功能，它们来自不同的计数器事件，如溢出、重载，以及来自每个捕获/比较寄存器。它还具有硬件设计来处理由内部或外部电路产生的故障信号，以指示系统中的故障。

## 通用定时器

**TIMG模块由16位和32位自动重新加载计数器组成**，由可编程预计算器驱动，具有两个捕获/比较（CC）块，用于多个捕获/比较、PWM输出和间隔定时。TIMG还具有广泛的事件生成功能，包括计数器溢出、重加载和针对各种用例的捕获/比较操作。

## 基本参数

### 预分频

**预分频器可以将定时器的时钟(TIMCLK)频率按1到256之间的任意值分频**（1到256是基于定时器分频器是8位），**TIMG可以选择BUSCLK、MFCLK、LFCLK作为时钟源，可以最大8分频时钟**，**再经过一个8位的预分频器，最终称为定时器的计数时钟**。

![8分频时钟](./demo/pic/8分频时钟.png)

### 向上或向下计数模式

**向上计数指的是计数器从0开始向上连续计数到自动加载值**，
一旦计数器计数到自动加载值，会**重新从0开始向上计数并产生上溢事件**。

**向下计数指的是计数器从自动加载值开始向下连续计数到0**，
一旦计数器计数到0，会**重新从自动加载值开始向下计数并产生下溢事件**。

### 更新事件

**更新事件是当计数器上溢或者下溢而开始新的计数周期时触发的**。
**更新事件可以触发DMA请求，以用于在下一个计数周期开始时及时更新定时器的运行参数**，特别适合用于实时控制。

## 配置定时器

这个还挺重要的，务必掌握

左侧功能栏选中 TIMER，然后如下配置：

![定时器TIMG配置方法](./demo/pic/定时器TIMG配置方法.png)

本例程中的实际参数如下： 定时器时钟选择BUSCLK-32MHz，进行8分频，再100预分频，得到定时器的频率为40KHz。设置定时器周期为1S，周期向下计数模式，开启0溢出中断。

然后我们还是控制 LED 以1s的周期闪烁

```c
#include "ti_msp_dl_config.h"

int main()
{
    SYSCFG_DL_init();
    // 清除定时器中断标志
    NVIC_ClearPendingIRQ(TIMER_0_INST_INT_IRQN);
    // 使能定时器中断
    NVIC_EnableIRQ(TIMER_0_INST_INT_IRQN);
    while (1);
}

// 定时器的中断服务函数 已配置为1秒的周期
void TIMER_0_INST_IRQHandler()
{
    // 如果产生了定时器中断
    switch (DL_TimerG_getPendingInterrupt(TIMER_0_INST)) {
        case DL_TIMER_IIDX_ZERO: // 如果是0溢出中断
            // 将LED灯的状态翻转
            DL_GPIO_togglePins(LED_PORT, LED_PIN_22_PIN);
            break;
        default: // 其他的定时器中断
            break;
    }
}
```

# PWM

PWM（Pulse Width Modulation 脉宽调制）是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术。它是一种对模拟信号电平进行数字编码的方法。**是指在一定时间内波形的高电平（即 1 状态）所占用的时间比例**。通过高分辨率计数器的使用，方波占空比被调制用来对一个模拟信号的电平进行编码。**PWM 信号依然是数字的，因为在给定的任何时刻，满幅值的直流供电要么完全有，要么完全无**。比如我们的电压输出是 5V的，**那么经过改变 PWM 的占空比，可以达到在一定时间内输出 3.3V 或者 1.3V 的效果**。

举个例子

想象你有一个LED和一个开关，你以肉眼看不清的速度，快速反复地开关一次，这样LED灯就会亮一半时间，暗一半时间。如果你快速地进行这个操作，对于观察者来说，LED就像是以半亮度持续亮着。这就是PWM的基本原理。

如果你把大部分时间保持开关为关闭状态，那么LED会显得更暗；相反，如果你把开关大部分时间保持为打开状态，LED会显得更亮。这就是PWM调节占空比来控制亮度的过程。

## PWM在MSPM0G上的实现

借助定时器来实现（和51一样了属于是）

PWM一共有两种模式。

1. **一个是边缘对齐PWM，指的是定时器使用的向下计数模式**，输出通道在定时器计数开始的时候会输出高电平， 当计数值与输出通道的比较值（图中的CC0和CCP0，CC1和CCP1）相同的时候， 输出通道会输出低电平，一直到定时器的计数值计数到0，就完成了一个周期的脉冲输出。
2. **另一个模式是中心对齐模式，指的是定时器的上下计数模式**，输出通道会在定时器开始的时候输出低电平，在定时器向上计数和向下计数两次到达输出通道的比较值相等的时候各翻转一次电平。

![边缘对齐PWM](./demo/pic/边缘对齐PWM.png)

![中心对齐PWM](./demo/pic/中心对齐PWM.png)

## PWM基本参数

PWM是脉冲宽度调制，具有两个非常重要的参数：频率和占空比。

- 频率：PWM的频率是整个周期的倒数。
- 占空比：占空比是指一个周期内高电平所占的比例。

## 控制方法

**采样控制理论中有一个重要结论：冲量相等而形状不同的窄脉冲加在具有惯性的环节上时，其效果基本相同**。PWM控制技术就是以该结论为理论基础，对半导体开关器件的导通和关断进行控制，使输出端得到一系列幅值相等而宽度不相等的脉冲，用这些脉冲来代替正弦波或其他所需要的波形。**按一定的规则对各脉冲的宽度进行调制，即可改变逆变电路输出电压的大小，也可改变输出频率**。

**控制方式就是对逆变电路开关器件的通断进行控制，使输出端得到一系列幅值相等但宽度不一致的脉冲，用这些脉冲来代替正弦波或所需要的波形**。也就是在输出波形的半个周期中产生多个脉冲，使个脉冲的等值电压为正弦波形，所获得的输出平滑且低次谐波少。按一定的规则对各脉冲的宽度进行调制，即可改变逆变电路输出电压的大小，也可改变输出频率。

嘶……某种意义上来说可以理解成另一种形式的傅里叶变换，只不过这次成方波了（笑）。

## PWM优点

**PWM的一个优点是从处理器到被控制系统信号都是数字形式，无需进行数模转换**。让信号保持为数字形式可将噪声影响降到最小。噪声只有在强到足以将逻辑1改变为逻辑0或将逻辑0改变为逻辑1时，才能对数字信号产生影响。对噪声抵抗能力的增强是PWM相对于模拟控制的另一个优点，而且这也是在某些时候将PWM用于通信的主要原因。

## PWM的应用

**PWM可应用于电机调速、功率调制、PID调节、通信等，配置简单、抗干扰能力强**。可以通过PWM来控制LED灯的亮暗变化，可以通过PWM信号来控制无源蜂鸣器发出简单的声音以及实现功率继电器的线圈节能等。PWM用来驱动电机和调节电机转速是非常重要的内容。

## 配置PWM

左边功能栏切换到 TIMER-PWM，然后会有如下页面：

![配置PWM](./demo/pic/配置PWM.png)

这里设置通道1为100Hz的频率，0%占空比的PWM，周期计数值为1000，比较值也设置为1000，这样的话从1000开始向下计数，每遇到一次1000，PWM的状态就翻转一次。引脚的设置。将LED的PB22引脚修改为PWM的输出引脚。而PB22支持TIMG8的通道1输出

管脚等设置需要去PinMux那里设置。

数据手册上PB22对应 TIMG8_C1（TIMG8的Channel 1），因此Timer Peripheral 配TIMG8，然后Capture/Compare Pin 1就应该是PB22/21

```c
#include "ti_msp_dl_config.h"

#define delay_ms(x) delay_cycles((CPUCLK_FREQ / 1000) * (x))

int main()
{
	int i =0;
	SYSCFG_DL_init();
	while (1)
	{
		for (i = 0; i <= 999; i++){
			DL_TimerG_setCaptureCompareValue(PWM_LED_INST,i,GPIO_PWM_LED_C1_IDX);
			delay_ms(1);
		}
		for (i = 999; i > 0; i--){
			DL_TimerG_setCaptureCompareValue(PWM_LED_INST,i,GPIO_PWM_LED_C1_IDX);
			delay_ms(1);
		}
	}
}
```

可以**通过函数 `DL_TimerG_setCaptureCompareValue` 设置定时器PWM的比较值，通过修改比较值看可以实现修改PWM的占空比**。
为什么for循环中`i`的范围是`0-999`？因为**我们设置的PWM的周期是计数1000个值，所以我们的比较值只能在0-999**。

# ADC

**ADC全称模拟-数字转换器，是一种用于将模拟信号转换为数字信号的模拟数字转换器**。我们知道，模拟信号是连续的，其取值可以在一定范围内任意变化，如声音、光信号等。而数字信号则是离散的二进制信号，如计算机中的数据0和1，仅能取有限的值。

**ADC的工作原理是将模拟信号通过采样转换为离散的数字信号，然后再通过量化、编码等处理，最终得到对应的数字表示**。ADC**采样的频率越高，得到的数字信号就越接近原来的模拟信号**，也就是**保真度越高**，**但是需要更多的资源和计算功耗**。

**ADC 通常用于从外部模拟传感器中读取模拟信号，并将其转换为数字信号供嵌入式系统或计算机进行处理**，例如测量温度、湿度、压力等物理量。

**MSPM0G3507采用的是逐次逼近型的12位ADC，它有 17个多路复用通道可以转换。17个外部通道，都对应单片机的某个引脚，这个引脚不是固定的**，详情请参考引脚图或者数据手册。

各种通道的 A/D 转换可以配置成 **单次、序列转换** 模式。

1. **单次转换模式**： 每次进行一次ADC转换后，ADC会自动停止，并将结果存储在ADC数据寄存器中。
2. **重复单次转换模式**： 当ADC完成一次转换后，它会自动启动另一次转换，持续的进行转换，直到外部触发或者软件触发的方式停止连续转换。
3. **多通道顺序单次转换模式**： 用于对多个输入通道进行依次转换。在该模式下，ADC会根据配置的通道采集顺序，对多个通道进行单次采样并转换。
4. **多通道顺序重复转换模式**： 用于对多个输入通道进行依次重复转换。在该模式下，ADC会根据配置的通道采集顺序，对多个通道进行重复采样并转换。

## ADC基本参数

1. **分辨率**： 表示**ADC转换器的输出精度，通常以位数（bit）表示**，比如8位、10位、12位等，**位数越高，精度越高**。MSPM0L1306支持8、10、12位的分辨率。
2. **采样率**： **表示ADC对模拟输入信号进行采样的速率，通常以每秒采样次数**（samples per second，SPS）**表示，也称为转换速率**，表示ADC能够进行多少次模拟到数字的转换。MSPM0G3507的SPS为4Msps。
3. **电压基准**： **ADC的电压基准是用于与模拟输入信号进行比较，从而实现模拟信号到数字信号的转换的一个参考电压。这个基准电压的准确性和稳定性对ADC的转换精度有着决定性的影响**。而MSPM0G3507可以支持软件选择三种基准：
    （1）1.4V 和 2.5V 的可配置内部专用 ADC 基准电压 (VREF)
    （2）MCU 电源电压 (VDD) 
    （3）通过 VREF+和 VREF- 引脚为 ADC 提供外部基准。如未配置电压基准则默认使用MCU电源电压作为ADC电压基准。
4. **采样范围**： 指ADC可以采集到的模拟输入信号的电压范围，范围见下：
    `VREF- ≤ ADC ≤ VREF+`
其中`VREF-` 为设置的电压基准负，通常为0V。`VREF+` 为电压基准正，根据软件的配置确定范围。

## 基本原理

MSPM0G3507采用的是**逐次逼近型**的ADC，逐次逼近型ADC是一种常见的ADC工作原理，

**它的思想是通过比较模拟信号与参考电压之间的大小关系来逐步逼近输入信号的数字表示**。在逐次逼近型ADC中，输入信号和参考电压被加入一个差分放大器中，产生一个差分电压。然后，这个差分电压被输入到一个逐步逼近的数字量化器中，该量化器以逐步递减的方式将其与一系列参考电压进行比较。具体来说，在每个逼近阶段，量化器将输入信号与一个中间电压点进行比较，将该电压点上方或下方的参考电压作为下一个逼近阶段的参考电压。这个过程一直持续到量化器逼近到最终的数字输出值为止。

## ADC优点

- 数字信号具有良好的抗干扰性。数字信号是由一系列离散的数字表示，因此可以抵抗模拟信号受到的各种干扰，如噪声、漂移等。
- 方便数字信号的存储、处理和传输。由于数字信号是离散的，因此它们可以轻松存储在计算机内存或其他数字设备中，方便进行处理和传输。
- 具有可编程性。现代的ADC出现了很多可编程的功能，例如可编程增益、采样率和滤波器等，可以根据不同的应用场景进行优化。
- 适用性广泛。ADC被广泛应用于工业、通信、医疗、电子测量、音频、视频等领域，可转换各种不同类型的模拟信号，包括电压、电流、声音、光信号等。

## ADC配置

本案例将以采集3.3V和GND的电压作为实验案例。通过ADC采集其电压变化，实现判断电压情况。

左边功能栏选择ADC12

![ADC配置](./demo/pic/ADC配置.png)

MSPM0G3507的ADC支持各种数据对齐方式以适应不同的应用场景。**常见的数据对齐方式包括左对齐和右对齐**。

**在右对齐模式下，ADC的数据在转换结束后被右对齐到最低位，不足的位数在高位填充0**。
右对齐模式允许实现**在没有精度的损失下更好的动态范围**。

![ADC右对齐模式](./demo/pic/ADC右对齐模式.png)

**在左对齐模式下，ADC的数据被左对齐到最高位，不足的位数在低位填充0**。左对齐模式**可以提高分辨率**，但**会导致动态范围降低**。

![ADC左对齐模式](./demo/pic/ADC左对齐模式.png)

接下来是配置ADC采集通道

![ADC采集通道配置](./demo/pic/ADC采集通道配置.png)

这里A0_0（ADC_CH0）对应PA27，我们再配置分辨率啥的：

![ADC分辨率配置](./demo/pic/ADC分辨率配置.png)

然后是开启中断（Interrupt Configuration），当ADC采集完成时触发中断，然后我们数据处理

然后我们还需要配一下UART啥的（默认配置即可），之后就可以把这一段代码烧进去了：

```c
#include "ti_msp_dl_config.h"
#include "stdio.h"

#define delay_ms(X) delay_cycles((CPUCLK_FREQ / 1000) * (X))

void uart0_send_string(char *str); // 串口发送数据
volatile bool gCheckADC;           // ADC采集成功标志位
unsigned int adc_getValue(void);   // 读取ADC的数据

int main(void)
{
    char show_buff[100]    = {0};
    unsigned int adc_value = 0;
    float voltage_value    = 0;

    SYSCFG_DL_init();

    // 开启ADC中断
    NVIC_EnableIRQ(ADC_VOLTAGE_INST_INT_IRQN);

    uart0_send_string("adc Demo start\r\n");
    while (1) {
        // 获取ADC数据
        adc_value = adc_getValue();
        sprintf(show_buff, "adc value:%d\r\n", adc_value);
        uart0_send_string(show_buff);

        // 将ADC采集的数据换算为电压
        voltage_value = adc_value / 4095.0 * 3.3;

        sprintf(show_buff, "voltage value:%.2f\r\n", voltage_value);
        uart0_send_string(show_buff);
        delay_ms(1000);
    }
}

// 串口发送字符串
void uart0_send_string(char *str)
{
    // 当前字符串地址不在结尾 并且 字符串首地址不为空
    while (*str != 0 && str != 0) {
        // 发送字符串首地址中的字符，并且在发送完成之后首地址自增
        DL_UART_transmitDataBlocking(UART_0_INST, *str++);
    }
}

// 读取ADC的数据
unsigned int adc_getValue(void)
{
    unsigned int gAdcResult = 0;

    // 软件触发ADC开始转换
    DL_ADC12_startConversion(ADC_VOLTAGE_INST);
    // 如果当前状态为正在转换中则等待转换结束
    while (false == gCheckADC) {
        __WFE();
    }
    // 获取数据
    gAdcResult = DL_ADC12_getMemResult(ADC_VOLTAGE_INST, ADC_VOLTAGE_ADCMEM_ADC_CH0);

    // 清除标志位
    gCheckADC = false;

    return gAdcResult;
}

// ADC中断服务函数
void ADC_VOLTAGE_INST_IRQHandler(void)
{
    // 查询并清除ADC中断
    switch (DL_ADC12_getPendingInterrupt(ADC_VOLTAGE_INST)) {
        // 检查是否完成数据采集
        case DL_ADC12_IIDX_MEM0_RESULT_LOADED:
            gCheckADC = true; // 将标志位置1
            break;
        default:
            break;
    }
}
```

顺带我们用了个`sprintf`，

函数原型为：`int sprintf(char *str, const char *format, ...);`

- `str`：指向字符数组的指针，该数组将用来存储格式化后的字符串。
- `format`：指向格式化字符串的指针，它指定了输出格式。
- `...`：可变参数列表，根据 format 中指定的格式占位符，可以是任意类型的数据。

实际示例为：

```c
#include <stdio.h>

int main() {
    char buffer[50];
    int num = 123;
    sprintf(buffer, "The number is: %d", num);
    printf("%s\n", buffer); // 输出: The number is: 123
    return 0;
}
```

# DMA


